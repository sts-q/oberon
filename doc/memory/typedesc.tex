\section{Type Descriptors}\label{memlay:type-descriptors}

Type descriptors are generated by the compiler for any type that can
be allocated on the heap.  These descriptors describe the runtime
shape of record and array types so that the \gc can follow pointers in
the dynamically allocated memory blocks.  The address of type
descriptors are stored in block tags of memory blocks by the memory
allocator.  Due to use in block tags, and the low-order bits
constraints shown in \figref{memlay:block-tag-values}, type
descriptors must be allocated on sixteen byte-aligned addresses.

\subsection{Descriptor Flags}\label{memlay:descriptor-flags}
The first four bytes of a block descriptor contain information about
the type of the descriptor.  Firstly, the low-order byte encodes an
integer which describes the \emph{kind} of the block descriptor.  The
invariant, of this low-order byte is: $\texttt{tag} \bmod 16 \in
\{0..9\}$.  The remaining three bytes of the field are reserved and
must be zero.

While the the block \emph{kind} determines the specific contents of a
memory block, a secondary, synthetic, attribute of a memory block is
the \emph{class}.  The \emph{class} describes the type of the element
contained in the block.  The relationship of \emph{kind} to
\emph{class} can be seen in \tabref{memlay:block-kinds}, while the
four classes are described in \tabref{memlay:block-class}.

\begin{table}[h]
  \begin{tabularx}{\textwidth}{|c|l|l|l|X|}
    \hline \S & Kind & Class &    Description & Name \\
    \hline \xref{memlay:td-record}   & 0 & 0 & record & n/a \\
    \hline \xref{memlay:td-dynarr0}  & 1 &   & array of integral type & DynArr0 \\
    \hline \xref{memlay:td-dynarr1}  & 2 & 2 & array of pointer type & DynArr1 \\
    \hline \xref{memlay:td-dynarr2}  & 3 & 1 & array of record type & DynArr2 \\
    \hline \xref{memlay:td-dynarr3}  & 4 &   & array of static array of integral type & DynArr3 \\
    \hline \xref{memlay:td-dynarr4}  & 5 & 2 & array of static array of pointer type & DynArr4 \\
    \hline \xref{memlay:td-dynarr5}  & 6 & 1 & array of static array of record type & DynArr5 \\
    \hline \xref{memlay:td-statarr0} & 7 &   & static array of integral type & StatArr0 \\
    \hline \xref{memlay:td-statarr1} & 8 & 2 & static array of pointer type & StatArr1 \\
    \hline \xref{memlay:td-statarr2} & 9 & 1 & static array of record type & StatArr2 \\
    \hline
  \end{tabularx}
  \caption{Kinds of allocated memory blocks}
  \label{memlay:block-kinds}
\end{table}

\begin{table}[h!]
  \begin{tabularx}{\linewidth}{|c|l|X|}
    \hline Class & Contents & Garbage Collection Semantics \\

    \hline 0 & record & The \gc traverses all pointers in the
    record. \\

    \hline 1 & array of record & The \gc traverses each element in the
    array, and every pointer in each record. \\

    \hline 2 & array of pointer & The \gc traverses each pointer. \\

    \hline n/a & array of integral & Integral types
    (e.g. \texttt{CHAR}, \texttt{REAL}, etc.) need no further
    collection. \\

    \hline
  \end{tabularx}
  \caption{Classes of allocated blocks}
  \label{memlay:block-class}
\end{table}

\subsection{Record}\label{memlay:td-record}

The compiler will generate a type descriptor as shown in
\figref{fig:rec-td-layout} for all record types, with the fields being
shown in \figref{fig:rec-td-layout}.

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\

    \begin{leftwordgroup}{$(\forall i: 0 \leq i < \alpha: -4(i + 1)$}
      \wordbox{1}{$\textrm{method}_{i}$} \end{leftwordgroup} \\

    \begin{leftwordgroup}{0} \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{\emph{extension table} address} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{extension level} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{record size} \end{leftwordgroup} \\

    \begin{leftwordgroup}{16} \wordbox{1}{record block size} \end{leftwordgroup} \\

    \begin{leftwordgroup}{20} \wordbox{1}{number of pointers} \end{leftwordgroup} \\
    \begin{leftwordgroup}{24} \wordbox{1}{record name address} \end{leftwordgroup} \\

    \begin{leftwordgroup}{28} \wordbox{1}{module descriptor} \end{leftwordgroup} \\

    \begin{leftwordgroup}{32} \wordbox{1}{finalization procedure} \end{leftwordgroup} \\

    \begin{leftwordgroup}{$(\forall i: 0 \leq i < \beta: 36 +
        4i)$\footnote{$\beta$ is the number of pointers declared in the
          record type}}
      \wordbox{1}{$\textrm{pointer offset}_i$} \end{leftwordgroup} \\

    \begin{leftwordgroup}{$36 + 4 \beta$} \wordbox{1}{gc sentinel pointer} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Record Descriptor Layout}\label{fig:rec-td-layout}
\end{figure}

\begin{TDfields}{extension table}
\item[method] $\alpha$ is the number of methods defined in the type.
  This is a table that contains pointers to type-bound procedures
  defined by the type.

  \item[flags] \xref{memlay:descriptor-flags}

  \item[extension table] This field points to a table that holds type
    descriptors of all the ancestors of this class $(\textrm{value}
    \neq \nil)$.

  \item[extension level]  The extension depth of this recrod from the
    topmost base record $(\textrm{value} \geq 0)$.

  \item[record size] This size of the record structure, in bytes
    $(\textrm{value} \geq 0)$.

  \item[block size] The minimum number of bytes needed by the heap
    allocator when dynamically allocating a record described by this
    descriptor.
    $$\left\lfloor\frac{\textrm{tag size} + \textrm{record size} +
      (\alpha - 1)}{\alpha}\right\rfloor \times \alpha$$

    $\alpha$ is implementation defined.  This implementation uses 16.

    This field is set by the heap allocator and used by the garbage
    collector when traversing the heap.

  \item[pointer count] The number of pointer field which are contained
    in the described record $(\textrm{value} \geq 0)$.

  \item[record name] A pointer to the ASCIIZ name of the record
    $(\textrm{value} \neq \nil)$.

  \item[module desc]
    The field references the \texttt{Kernel.Module} instance for the
    module which owns this TD.

     $\nil \implies \textrm{module descriptors not supported}$

  \item[finalization] This field is reserved ($\textrm{value} = 0$).

  \item[pointer offsets] A block of signed, positive, four byte of
    integers that are offsets in the record where pointers reside.

  \item[sentinel offset] This sentinal value is designed so that the
    \gc will reproduce the original offset into the pointer table of
    the type descriptor value when the last pointer of the record has
    been followed.

    See \underline{Project Oberon} $\S$8.3 for more info on this
    technique.

    The value contained in this field is calculated with the following:

    $$-(\textrm{pointer table offset} + \textrm{number of pointers}
    \times \texttt{SIZE(LONGINT)})$$
\end{TDfields}


The \emph{extension table} as generated by the compiler will contain
the type descriptors of all ancestor types.  It is indexed by an
\emph{extension level}, and will have the format shown in
\figref{tab:type-extension-table}.

\begin{figure}[h!]
\begin{bytefield}{31}
  \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
  \begin{leftwordgroup}{0} \wordbox{1}{TD Level 0} \end{leftwordgroup} \\
  \begin{leftwordgroup}{4} \wordbox[lrt]{1}{TD Level 1} \end{leftwordgroup} \\
  \skippedwords \\
  \begin{leftwordgroup}{$8 + (\textrm{extension level} - 1) \times 4$} \wordbox[lrb]{1}{$\textrm{TD Level}_{\textrm{extension level} - 1}$} \end{leftwordgroup}
\end{bytefield}
\caption{Type Extension Table}\label{tab:type-extension-table}
\end{figure}


\subsection{Dynamic Array}

There are two different types of dynamic array implementations in the
Oberon runtime system:

\begin{itemize}
\item{stack based}

  Stack based arrays are \emph{open array parameters}, and do not have
  a type descriptor.

\item{heap based}

  Heap based arrays are \emph{dynamically allocated} with the standard
  procedure \texttt{NEW(array, $\texttt{dim}_0$, $\texttt{dim}_1$,
    $...$, $\texttt{dim}_{n-1}$)} and do have a type descriptor.

\end{itemize}

There are a great variety of dynamic arrays that can be allocated on
the heap, and with each comes a unique type descriptor format.  The
formats are described in the following sections.

\subsubsection{DynArr0}\label{memlay:td-dynarr0}

A dynamic array of integral or procedure type will have a type
descriptor as shown in \figref{fig:dynarr0-td}.  Note that the
elements of this type of array do not need inspection when garbage
collecting.

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{element type} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{element size} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{DynArr0 Type Descriptor Layout}
  \label{fig:dynarr0-td}
\end{figure}

\begin{TDfields}{element type}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[element type] Contains the compiler's \emph{type form} of the
    array element ($\textrm{value} \in \setof{bool, byte, char, sint, int, lint,
      real, lreal, set, procedure}$).

  \item[dimensions]  The number of dimensions of the array.

    $\textrm{value} > 0$

  \item[element size]  The size, in bytes, of an element of this array.

    $(\textrm{value} > 0) \wedge (\textrm{value} \leq 8)$

\end{TDfields}


\subsubsection{DynArr1}\label{memlay:td-dynarr1}

A dynamic array of pointer type will have a type descriptor as shown
in \figref{fig:dynarr1-td}.

\begin{TDfields}{element size}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[reserved] Reserved ($\textrm{value} = 0$).

  \item[dimensions]  The number of dimensions of the array.
    $\textrm{value} > 0$

  \item[element size]  The size, in bytes, of an element of this array.
    $(\textrm{value} > 0) \wedge (\textrm{value} \leq 8)$

\end{TDfields}

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{reserved} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{element size} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{DynArr1 Type Descriptor Layout} \label{fig:dynarr1-td}
\end{figure}

\subsubsection{DynArr2}\label{memlay:td-dynarr2}

A dynamic array of a record type will have a type descriptor as shown
in \figref{fig:dynarr2-td}.

\begin{TDfields}{element type}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[element type]  Contains the compiler's \emph{type form} of the
    array element ($\textrm{value} = \texttt{record}$).

  \item[dimensions]  The number of dimensions of the array
    ($\textrm{value} > 0$).

  \item[element size] The size, in bytes, of an element of this array
    ($\textrm{value} > 0$).
\end{TDfields}


\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{element type} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{element size} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{DynArr2 Type Descriptor Layout} \label{fig:dynarr2-td}
\end{figure}

\subsubsection{DynArr3}\label{memlay:td-dynarr3}
A dynamic array of a static array with an integral or procedure
element type will have a descriptor as shown in \figref{fig:dynarr3-td}.

\begin{TDfields}{dynamic dimensions}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[element type]  Contains the compiler's \emph{type form} of the
    array element ($\textrm{value} = \texttt{record}$).


  \item[dynamic dimensions]  The number of dynamic dimensions of the array
    ($\textrm{value} > 0$).

  \item[element size]  The size, in bytes, of an element of this array
    ($\textrm{value} > 0$).

  \item[static dimensions] The number of static dimensions declared in
    the module source ($\textrm{value} > 0$).

  \item[\texttt{LEN(x, i)}] A table of lengths used when allocating
    the array.
\end{TDfields}

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{element type} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{dynamic dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{element size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{16} \wordbox{1}{static dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: 20 + 4i)$}
      \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{DynArr3 Type Descriptor Layout} \label{fig:dynarr3-td}
\end{figure}


\subsubsection{DynArr4}\label{memlay:td-dynarr4}

A dynamic array of a static array with a pointer type element will
have a descriptor as shown in \figref{fig:dynarr4-td}.

\begin{TDfields}{dynamic dimensions}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[reserved]  Reserved ($\textrm{value} = 0$).

  \item[dynamic dimensions]  The number of dynamic dimensions of the array
    ($\textrm{value} > 0$).

  \item[element size]  The size, in bytes, of an element of this array
    ($\textrm{value} > 4$).

  \item[static dimensions] The number of static dimensions declared in
    the module source ($\textrm{value} > 0$).

  \item[\texttt{LEN(x, i)}] A table of lengths used when allocating
    the array.
\end{TDfields}


\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{reserved} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{dynamic dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{element size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{16} \wordbox{1}{static dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: 20 + 4i)$}
      \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{DynArr4 Type Descriptor Layout} \label{fig:dynarr4-td}
\end{figure}

\subsubsection{DynArr5}\label{memlay:td-dynarr5}

A dynamic array of a static array with record type element will have a
descriptor as shown \figref{fig:dynarr5-td}.

\begin{TDfields}{dynamic dimensions}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[type descriptor] Address of type descriptor of record type
    ($\textrm{value} \neq \nil$).


  \item[dynamic dimensions]  The number of dynamic dimensions of the array
    ($\textrm{value} > 0$).

  \item[element size]  The size, in bytes, of an element of this array
    ($\textrm{value} > 4$).

  \item[static dimensions] The number of static dimensions declared in
    the module source ($\textrm{value} > 0$).

  \item[\texttt{LEN(x, i)}] A table of lengths used when allocating
    the array.
\end{TDfields}


\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{record type descriptor} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{dynamic dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{element size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{16} \wordbox{1}{static dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: 20 + 4i)$}
      \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{DynArr5 Type Descriptor Layout} \label{fig:dynarr5-td}
\end{figure}

\subsection{Static Array}
A pointer to a statically sized array can also be allocated on the
heap, and therefore also requires a type descriptor.  The following
sections will describe the type descriptors for all the types of
static arrays that can be allocated.

\subsubsection{StatArr0}\label{memlay:td-statarr0}

A static array with an integral or procedure type element type will
have a descriptor as shown in \figref{fig:statarr0-td}.

\begin{TDfields}{static dimensions}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[element type] Contains the compiler's \emph{type form} of the
    array element ($\textrm{value} \in \setof{bool, byte, char, sint, int, lint,
      real, lreal, set, procedure}$).

  \item[element size]  The size, in bytes, of an element of this array
    ($(\textrm{value} > 0) \wedge (\textrm{value} \leq 8)$).

  \item[static dimensions] The number of static dimensions declared in
    the module source ($\textrm{value} > 0)$.

  \item[\texttt{LEN(x, i)}] A table of lengths used when allocating
    the array.
\end{TDfields}

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{element type} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{element size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{static dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: 16 + 4i)$}
      \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{StatArr0 Type Descriptor Layout} \label{fig:statarr0-td}
\end{figure}


\subsubsection{StatArr1}\label{memlay:td-statarr1}
A static array with n pointer type element type which will have a
descriptor as shown in \figref{fig:statarr1-td}.

\begin{TDfields}{static dimensions}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[reserved]  Reserved ($\textrm{value} = 0$).

  \item[element size]  The size, in bytes, of an element of this array
    ($\textrm{value} = 4)$).


  \item[static dimensions] The number of static dimensions declared in
    the module source ($\textrm{value} > 0)$.

  \item[\texttt{LEN(x, i)}] A table of lengths used when allocating
    the array.
\end{TDfields}

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{reserved} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{element size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{static dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: 16 + 4i)$}
      \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{StatArr1 Type Descriptor Layout} \label{fig:statarr1-td}
\end{figure}

\subsubsection{StatArr2}\label{memlay:td-statarr2}

A static array with a record element type will have a descriptor as
shown \figref{fig:statarr2-td}.

\begin{TDfields}{static dimensions}
  \item[flags] \xref{memlay:descriptor-flags}

  \item[type descriptor] Address of type descriptor of record type
    ($\textrm{value} \neq \nil$).

  \item[element size]  The size, in bytes, of an element of this array
    ($\textrm{value} >= 0)$).


  \item[static dimensions] The number of static dimensions declared in
    the module source ($\textrm{value} > 0)$.

  \item[\texttt{LEN(x, i)}] A table of lengths used when allocating
    the array.
\end{TDfields}


\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{flags} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{record type descriptor} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{element size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12} \wordbox{1}{static dimensions} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: 16 + 4i)$}
      \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{StatArr2 Type Descriptor Layout} \label{fig:statarr2-td}
\end{figure}

\section{Stack-based Array}

A stack based dynamic array has the format shown in \figref{fig:stack-based-dynarr}.


\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{array data address} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: 4 + 4i)$}
      \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Stack-based Dynamic Array} \label{fig:stack-based-dynarr}
\end{figure}

\section{Heap-based Array}\label{memlay:heap-array}

Note that since the array data begins at offset zero, the array
descriptor appears prior to the type tag at negative offsets.  This
means that a pointer to a dynamically allocated array does not point
at the beginning of the memory block.  It is the responsibility of the
heap allocation system to manage the extra padding required by the
array descriptor.

\subsection{Integral Element}

A heap-based dynamic array of a integral element type has a format
shown in \figref{fig:heap-based-integral-arr}.

\begin{TDfields}{external tag}
  \item[external tag] The external tag refers to the internal tag
    ($\textrm{value} = \alpha + \setof{BlkAray}$).

  \item[block size] The number of bytes in this memory block.  Set by
    the allocator.

  \item[padding] The padding necessary to ensure the actual array data
    begins at a sixteen byte boundary is dependent on the number of
    dimensions in the array.  The value of each word of padding is
    zero.

  \item[\texttt{LEN}] The memory allocator will set each dimensions
    length in these fields.

  \item[internal tag]  The internal tag refers to the actual type
    descriptor for the allocated block.

  \item[array data]  The remainder of the memory block is the actual
    array data.  It will be initialized to binary zero.
\end{TDfields}

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{-4}  \wordbox{1}{(external tag) preamble} \end{leftwordgroup} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{block size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha - 8 - 4n$}  \wordbox{1}{padding} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: \alpha - 4 - 4(n
        - i))$} \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha - 4$} \wordbox{1}{(internal tag) type descriptor} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha$} \wordbox{1}{array data} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Heap-based Integral Type Array} \label{fig:heap-based-integral-arr}
  %% FIXME: Give a commentary about why the array lengths are -1.
\end{figure}

\subsection{Pointer Element}

A heap-based dynamic array of a pointer element type has a format
shown in \figref{fig:heap-based-pointer-arr}.

\begin{TDfields}{total elements}
  \item[external tag] The external tag refers to the internal tag
    ($\textrm{value} = \alpha + \setof{BlkAray}$).

  \item[block size] The number of bytes in this memory block.  Set by
    the allocator.

  \item[total elements] The total number of elements in the allocated
    array.

  \item[q.arrpos] This field is reserved for use by the \gc to track
    the current position within an array.

  \item[padding] The padding necessary to ensure the actual array data
    begins at a sixteen byte boundary is dependent on the number of
    dimensions in the array.  The value of each word of padding is
    zero.

  \item[\texttt{LEN}] The memory allocator will set each dimensions
    length in these fields.

  \item[internal tag]  The internal tag refers to the actual type
    descriptor for the allocated block.

  \item[array data]  The remainder of the memory block is the actual
    array data.  It will be initialized to binary zero.
\end{TDfields}

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{-4}  \wordbox{1}{(external tag) preamble} \end{leftwordgroup} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{block size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{total elements} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{\texttt{q.arrpos}} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha - 8 - 4n$}  \wordbox{1}{padding} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: \alpha - 4 - 4(n
        - i))$} \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha - 4$} \wordbox{1}{(internal tag) type descriptor} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha$} \wordbox{1}{array data} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Heap-based Pointer Type Array} \label{fig:heap-based-pointer-arr}
\end{figure}


\subsection{Record Element}

A heap-based dynamic array of a record element type has a format shown
in \figref{fig:heap-based-record-arr}.

\begin{TDfields}{total elements}
  \item[external tag] The external tag refers to the internal tag
    ($\textrm{value} = \alpha + \setof{BlkAray}$).

  \item[block size] The number of bytes in this memory block.  Set by
    the allocator.

  \item[total elements] The total number of elements in the allocated
    array.

  \item[q.arrpos] This field is reserved for use by the \gc to track
    the current position within an array.

  \item[q.cnt] This field is reserved for use by the \gc to track
    progress on collecting the array.

  \item[padding] The padding necessary to ensure the actual array data
    begins at a sixteen byte boundary is dependent on the number of
    dimensions in the array.  The value of each word of padding is
    zero.

  \item[\texttt{LEN}] The memory allocator will set each dimensions
    length in these fields.

  \item[internal tag]  The internal tag refers to the actual type
    descriptor for the allocated block.

  \item[array data]  The remainder of the memory block is the actual
    array data.  It will be initialized to binary zero.
\end{TDfields}


\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{-4}  \wordbox{1}{(external tag) preamble} \end{leftwordgroup} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{block size} \end{leftwordgroup} \\
    \begin{leftwordgroup}{4}  \wordbox{1}{total elements} \end{leftwordgroup} \\
    \begin{leftwordgroup}{8}  \wordbox{1}{\texttt{q.arrpos}} \end{leftwordgroup} \\
    \begin{leftwordgroup}{12}  \wordbox{1}{\texttt{q.cnt}} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha - 8 - 4n$}  \wordbox{1}{padding} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$(\forall i: 0 \leq i < n: \alpha - 4 - 4(n
        - i))$} \wordbox{1}{\texttt{LEN(x, i) - 1}} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha - 4$} \wordbox{1}{(internal tag) type descriptor} \end{leftwordgroup} \\
    \begin{leftwordgroup}{$\alpha$} \wordbox{1}{array data} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Heap-based Record Type Array} \label{fig:heap-based-record-arr}
\end{figure}


\section{Heap-based Record}

A heap-based record has a format shown in \figref{fig:heap-based-record}.

\begin{figure}[h!]
  \begin{bytefield}{31}
    \bitheader[endianness=big]{0,7,8,15,16,23,24,31} \\
    \begin{leftwordgroup}{-4}  \wordbox{1}{tag / q.cnt} \end{leftwordgroup} \\
    \begin{leftwordgroup}{0}  \wordbox{1}{record data} \end{leftwordgroup} \\
  \end{bytefield}
  \caption{Heap-based Record} \label{fig:heap-based-record}
\end{figure}

\section{Examples}
The following sections are provide examples of how each type of
heap-allocated memory block will appear in memory.

\subsection{DynArr0}

For information about the layout of the type descriptor for
these arrays, see \xref{memlay:td-dynarr0}.

\begin{alltt}
VAR
  x : POINTER TO ARRAY OF REAL;

NEW(x, 50);
\end{alltt}

An allocated block containing an instance of \texttt{x} it will be
stored as shown in \figref{fig:example-dynarr0}

\begin{figure}[h!]
  \begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
    \cline{2-3} -4  & $16 + \setof{BlkAray}$ &    address of array \\
    \cline{2-3} 0 &   set by allocator &  block size \\
    \cline{2-3} 4 &   reserved &          padding \\
    \cline{2-3} 8 &   49 &                LEN(x, 0)-1 \\

    \cline{2-3} \cline{5-6} 12 & $\texttt{ADR(TD)} + \setof{BlkAray}$ & address of TD
    & \implies &  1 & flags & 0 \\

    \cline{2-3} \cline{5-6}  16 &  &                  array data
    & & 7 & type form & 4 \\

    \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{} & 1 & nofDim & 8 \\

    \cline{5-6} \multicolumn{4}{l|}{} & 4\footnote{$\size{REAL} \equiv 4$} & elSize & 12 \\
    \cline{5-6}
  \end{tabularx}
  \caption{DynArr0 example} \label{fig:example-dynarr0}
\end{figure}

\reqGC{Mark the block as reachable (if it is).  No internal GC
  needed.}

\subsection{DynArr1}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-dynarr1}.

\begin{alltt}
TYPE
  T0 : POINTER TO RECORD (* ... *) END;

VAR
  x : POINTER TO ARRAY OF ARRAY OF T0;

NEW(x, 50, 20);
\end{alltt}

\begin{figure}[h!]
\begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
  \cline{2-3}                  -4  & $32 + \setof{BlkAray}$       & address of array     \\ % data only

  \cline{2-3}                   0  & \sba      & block size     \\ % data only

  \cline{2-3}                   4  & $50 \times 20$      & \rfgc{nofElem}     \\ % data only
  \cline{2-3}                   8  & array position      & \rfgc{q.arrpos}     \\ % data only

  \cline{2-3}                  12  & \resv      & padding     \\ % data only
  \cline{2-3}                  16  & \resv      & padding     \\ % data only

  \cline{2-3}                  20  & 49      & $\len{x}{0} - 1$     \\ % data only

  \cline{2-3}                  24  & 19      & $\len{x}{1} - 1$     \\ % data only

  \cline{2-3} \cline{5-6}      28  & $\adr{TD} + \setof{BlkAray}$      & address of TD     & \implies
  & 2      & flags      &  0\\ % data & TD top

  \cline{2-3} \cline{5-6}      32  &       & array data &
  &  \resv     &       &  4\\ % data & TD

  \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}              & 2            & nofDim      &  8\\ % data bot & TD
  \cline{5-6}             \multicolumn{4}{l|}{}              & \size{T0}    & elSize      &  12\\ % TD
  \cline{5-6}                                                                      % TD bot
\end{tabularx}
\end{figure}

\reqGC{Each element of the array must be traversed as a regular heap
  pointer.}

\subsection{DynArr2}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-dynarr2}.

\begin{alltt}
VAR
  x : POINTER TO ARRAY OF RECORD (* ... *) END;

NEW(x, 50);
\end{alltt}

\begin{figure}[h!]
\begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
  \cline{2-3}              -4  & $32 + \setof{BlkAray}$       & address of array      \\ % data only
  \cline{2-3}               0  & \sba      & block size     \\ % data only
  \cline{2-3}               4  & 50      & \rfgc{length}     \\ % data only
  \cline{2-3}               8  & q.arrpos      & \rfgc{q.arrpos}      \\ % data only
  \cline{2-3}              12  & q.cnt      & \rfgc{q.cnt}     \\ % data only
  \cline{2-3}              16  & \resv      & padding     \\ % data only
  \cline{2-3}              20  & \resv      & padding     \\ % data only
  \cline{2-3}              24  & 49      &  $\len{x}{0} - 1$    \\ % data only
  \cline{2-3} \cline{5-6}  28  & $\adr{TD} + \setof{BlkAray}$ &address of TD  & \implies & 3 & flags & 0 \\ % data & TD top
  \cline{2-3} \cline{5-6}  32  &       &  array data    &          &  address & TD & 4 \\ % data & TD
  \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}          & 1      & nofDim         & 8\\ % data bot & TD
  \cline{5-6}             \multicolumn{4}{l|}{}          &
  \size{record}      & elSize       &  12\\ % TD
  \cline{5-6}                                                                  % TD bot
\end{tabularx}
\end{figure}

\reqGC{Collect each element as a normal record variable would be
  collected.}

\subsection{DynArr3}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-dynarr3}.

\begin{alltt}
VAR
  x : POINTER TO ARRAY OF ARRAY 10 OF LONGINT;

NEW(x, 50);
\end{alltt}


\begin{figure}[h!]
  \begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
    \cline{2-3}               -4 & $16 + \setof{BlkAray}$      & address of array     \\ % data only
    \cline{2-3}                0 & \sba      & block size     \\ % data only
    \cline{2-3}                4 & \resv      & padding     \\ % data only
    \cline{2-3}                8 & 49      & $\len{x}{0} - 1$     \\ % data only
    \cline{2-3} \cline{5-6}   12 & $\adr{TD} + \setof{BlkAray}$ & address of TD & \implies & 4 & flags & 0 \\ % data & TD top
    \cline{2-3} \cline{5-6}   16 &       & array data &          & lint       & \etf & 4 \\ % data & TD
    \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}          & 1      & nofDim (dynamic)       & 8 \\ % data bot & TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 40 & \elsize\footnote{$10 \times \size{LONGINT}$}       & 12 \\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 1      & nofDim (static)       & 16 \\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 10      & $\len{x[n]}{0}$      & 20 \\ % TD
    \cline{5-6}                                                                      % TD bot
  \end{tabularx}
\end{figure}

\reqGC{Mark the block as reachable (if it is).  No internal GC
  needed.}

\subsection{DynArr4}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-dynarr4}.

\begin{alltt}
TYPE
  T0 = POINTER TO RECORD (* ... *) END;

VAR
  x : POINTER TO ARRAY OF ARRAY 10 OF T0;

NEW(x, 50);
\end{alltt}

\begin{figure}[h!]
  \begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
    \cline{2-3}               -4 & $32 + \setof{BlkAray}$      & address of array \\ % data only
    \cline{2-3}                0 & \sba      & block size     \\ % data only
    \cline{2-3}                4 & 50      & \rfgc{nofElem}      \\ % data only
    \cline{2-3}                8 & q.arrpos       & \rfgc{q.arrpos}      \\ % data only
    \cline{2-3}               12 & \resv      & padding     \\ % data only
    \cline{2-3}               16 & \resv      & padding     \\ % data only
    \cline{2-3}               20 & \resv      & padding     \\ % data only
    \cline{2-3}               24 & 49      & $\len{x}{0} - 1$     \\ % data only
    \cline{2-3} \cline{5-6}   28 & $\adr{TD} + \setof{BlkAray}$ & address of TD & \implies&5&flags& 0 \\ % data & TD top
    \cline{2-3} \cline{5-6}   32 &       &      &          & \resv      &       & 4 \\ % data & TD
    \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}          & 1      & nofDim (dynamic)       & 8 \\ % data bot & TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & $\alpha$ & \elsize\footnote{$\alpha \equiv 10 \times \size{T0}$}      & 12 \\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 1      & nofDim (static)       & 16 \\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 10     & $\len{x[n]}{0}$       & 20 \\ % TD
    \cline{5-6}                                                                      % TD bot
  \end{tabularx}
\end{figure}

\reqGC{Each element of each array must be traversed as a regular heap
  pointer.}

\subsection{DynArr5}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-dynarr5}.

\begin{alltt}
VAR
  x : POINTER TO ARRAY OF ARRAY 10 OF RECORD (* ... *) END;

NEW(x, 50);
\end{alltt}

\begin{figure}[h!]
  \begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
    \cline{2-3}               -4 & $32 + \setof{BlkAray}$      & address of array     \\ % data only
    \cline{2-3}                0 & \sba      & block size      \\ % data only
    \cline{2-3}                4 & 50      & \rfgc{nofElem}      \\ % data only
    \cline{2-3}                8 & q.arrpos   & \rfgc{q.arrpos}      \\ % data only
    \cline{2-3}               12 & q.cnt      & \rfgc{q.cnt}     \\ % data only
    \cline{2-3}               16 & \resv      & padding     \\ % data only
    \cline{2-3}               20 & \resv      & padding     \\ % data only
    \cline{2-3}               24 & 49      & $\len{x}{0} - 1$     \\ % data only
    \cline{2-3} \cline{5-6}   28 & $\adr{TD} + \setof{BlkAray}$ &address of TD & \implies &6&flags& 0 \\ % data & TD top
    \cline{2-3} \cline{5-6}   32 &       & array data     &    & address     & address of TD      & 4 \\ % data & TD
    \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{} & 1      & nofDim (dynamic)       & 8 \\ % data bot & TD
    \cline{5-6}             \multicolumn{4}{l|}{} & $\beta$ & \elsize\footnote{$\beta \equiv 10 \times \size{record}$}& 12 \\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 16       & nofDim (static)      & 16 \\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 10 &$\len{x[n]}{0}$       & 20 \\ % TD
    \cline{5-6}                                                                      % TD bot
  \end{tabularx}
\end{figure}

\reqGC{Collect each element in each array as a normal record variable
  would be collected.}

\subsection{StatArr0}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-statarr0}.

\begin{alltt}
VAR
  x : POINTER TO ARRAY 10 OF LONGINT;*

NEW(x);
\end{alltt}

\begin{figure}[h!]
  \begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
    \cline{2-3}               -4 & $16 + \setof{BlkAray}$      & address of array\\ % data only
    \cline{2-3}                0 & \sba      & block size     \\ % data only
    \cline{2-3}                4 & \resv      & padding      \\ % data only
    \cline{2-3}                8 & 9      & $\len{x}{0} - 1$      \\ % data only
    \cline{2-3} \cline{5-6}   12 & $\adr{TD} + \setof{BlkAray}$ & address of TD & \implies &7&flags&  0\\ % data & TD top
    \cline{2-3} \cline{5-6}   16 &       &array data&          &lint& \etf       &  4\\ % data & TD
    \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}          &4&\elsize\footnote{\size{LONGINT}}&  8\\ % data bot & TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 1      & nofDim       &  12\\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & 10     & $\len{0}{0}$      &  16\\ % TD
    \cline{5-6}                                                                      % TD bot
  \end{tabularx}
\end{figure}

\reqGC{Mark the block as reachable (if it is).  No internal GC
  needed.}

\subsection{StatArr1}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-statarr1}.

\begin{alltt}
TYPE
  T0 = POINTER TO RECORD (* ... *) END;

VAR
  x : POINTER TO ARRAY 10 OF T0;

NEW(x);
\end{alltt}

\begin{figure}[h!]
\begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
  \cline{2-3}               -4 & $32 + \setof{BlkAray}$      & address of array\\ % data only
  \cline{2-3}                0 & \sba       & block size     \\ % data only
  \cline{2-3}                4 & 10      & \rfgc{nofElem}      \\ % data only
  \cline{2-3}                8 & q.arrpos      & \rfgc{q.arrpos}     \\ % data only
  \cline{2-3}               12 & \resv      & padding     \\ % data only
  \cline{2-3}               16 & \resv      & padding     \\ % data only
  \cline{2-3}               20 & \resv      & padding     \\ % data only
  \cline{2-3}               24 & 9      & $\len{x}{0} - 1$      \\ % data only
  \cline{2-3} \cline{5-6}   28 & $\adr{TD} + \setof{BlkAray}$& address of TD& \implies &8&flags&  0\\ % data & TD top
  \cline{2-3} \cline{5-6}   32 &       & array data      &          &\resv       &       &  4\\ % data & TD
  \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}          &4 &\elsize\footnote{$\size{POINTER}$}&  8\\ % data bot & TD
  \cline{5-6}             \multicolumn{4}{l|}{}          & 1       & nofDim      &  12\\ % TD
  \cline{5-6}             \multicolumn{4}{l|}{}          &10       & $\len{x}{0}$  &  16\\ % TD
  \cline{5-6}                                                                      % TD bot
\end{tabularx}
\end{figure}

\reqGC{Each element of the array must be traversed as a regular heap
  pointer.}

\subsection{StatArr2}

For information about the layout of the type descriptor for these
arrays, see \xref{memlay:td-statarr2}.

\begin{alltt}
VAR
  x : POINTER TO ARRAY 10 OF RECORD (* ... *) END;

NEW(x);
\end{alltt}


\begin{figure}[h!]
\begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
  \cline{2-3}               -4 & $32 + \setof{BlkAray}$      & address of array\\ % data only
  \cline{2-3}                0 & \sba      & block size      \\ % data only
  \cline{2-3}                4 & 10      & \rfgc{nofElem}      \\ % data only
  \cline{2-3}                8 & q.arrpos       & \rfgc{q.arrpos}     \\ % data only
  \cline{2-3}               12 & q.cnt      & \rfgc{q.cnt}      \\ % data only
  \cline{2-3}               16 & \resv      & padding     \\ % data only
  \cline{2-3}               20 & \resv      & padding     \\ % data only
  \cline{2-3}               24 & 9      & $\len{x}{0} - 1$      \\ % data only
  \cline{2-3} \cline{5-6}   28 & $\adr{TD} + \setof{BlkAray}$& address of TD & \implies &9&flags&  0\\ % data & TD top
  \cline{2-3} \cline{5-6}   32 &       & array data      &          & address & address of TD       &  4\\ % data & TD
  \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}          & \size{record}  & \elsize      &  8\\ % data bot & TD
  \cline{5-6}             \multicolumn{4}{l|}{}          & 1      & nofDim      &  12\\ % TD
  \cline{5-6}             \multicolumn{4}{l|}{}          & 10      & \len{x}{0}       &  16\\ % TD
  \cline{5-6}                                                                      % TD bot
\end{tabularx}
\end{figure}

\reqGC{Collect each element in the array as a normal record variable
  would be collected.}

\subsection{Record}

\begin{alltt}
VAR
  x : POINTER TO RECORD (* ... *) END;

NEW(x);
\end{alltt}


\begin{figure}[h!]
  \begin{tabularx}{\linewidth}{r|r|l|c|r|l|l}
    \cline{2-3} \cline{5-6}   -8 & q.cnt      & \rfgc{q.cnt}      &
    & \unknown      & method pointers      &  -4\\ % data & TD

    \cline{2-3} \cline{5-6}   -4 & address of td       & address of TD     & \implies
    &     0  & flags      &  0\\ % data & TD top

    \cline{2-3} \cline{5-6}    0 & \size{record}       & record data     &
    &\unknown       & address of extension table      &  4\\ % data & TD

    \cline{2-3} \cline{5-6} \multicolumn{4}{l|}{}          &  0 & extension level      &  8\\ % data bot & TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & \size{record}  & record size      &  12\\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & \unknown  & \rfgc{block size}       &  16\\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & \unknown  & number of pointers      &  20\\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & \unknown  & address of record name      &  24\\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & \unknown  & address of module descriptor      &  28\\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & \unknown  & finalization      &  32\\ % TD
    \cline{5-6}             \multicolumn{4}{l|}{}          & \unknown  & pointer offset table      &  36\\ % TD
    \cline{5-6}                                                                      % TD bot
  \end{tabularx}
\end{figure}

\reqGC{The record pointer table must be traversed (obtained from the
  type descriptor), and each pointer in the record must be collected.
  See * for information on the type descriptor for a block of this
  type.}
